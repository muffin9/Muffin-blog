---
date: '2022-01-18'
title: '[NetWork] - HTTP'
categories: ['HTTP']
summary: 'HTTP도 버전마다...'
thumbnail: 'images/HTTP.png'
---

## HTTP ?

HTTP는 웹에서 클라이언트-서버가 정보를 주고받기 위한 프로토콜로 TCP/IP 계층에서 동작한다. 포트는 well-known 포트인 80번 포트를 사용하여 통신하며, 첫번째 표준은 HTTP/1.1이며 이후로 HTTP/2 및 HTTP/3가 등장하게 되었다. (HTTP 1.1 이전에는 0.9, 1.0 버전도 있긴한데 표준화가 아니다 보니 깊게 볼 필욘 없다 생각해서 패스)

## HTTP 요청 헤더

- Host : 서버의 도메인 이름과 TCP 포트번호
- Content-Type : POST/PUT 메서드를 사용할 때 본문의 타입
- If-Modified-Since : 명시한 날짜 이후로 변경된 리소스만 획득
- Origin : 요청이 어느 도메인에서 왔는지 명시, 서버의 Access-Control-\* 속성에 기입
- Cookie : 서버의 Set-Cookie 로 설정된 쿠키 값

## HTTP 응답 헤더

- Access-Control-\* : CORS를 허용하기 위한 웹사이트 명시
- Set-Cookie : 클라이언트에 쿠키 설정
- Last-Modified : 요청한 리소스가 마지막으로 변경된 시각
- Location : 3xx 상태 코드일 때, 리다이렉션 되는 주소
- Allow : 요청한 리소스에 대해 가능한 메서드들

## HTTP/1.1 특징

1. Connection Keep-Alive => 기존 연결에 대해서 handshake 생략가능하다.
2. 캐시 제어 메커니즘
3. 동일 IP 주소에 다른 도메인을 호스트하는 기능 가능
4. 언어, 인코딩 타입등을 포함한 컨텐츠 전송할 수 있다.
5. 파이프라이닝 추가함으로 이전 요청에 대한 응답이 완전히 전송되기 전에 다음 전송을 가능하게 하여 레이턴시를 낮추었다.

위 특징중 가장 핵심적인 부분은 요청 헤더의 Connection: keep-alive 속성으로 지속적 연결 상태(Persistent connection)를 유지할 수 있다는 점이다. => 요청을 할 때마다 연결하지 않고 기존의 연결을 재사용하는 방식으로 HTTP 1.1 부턴 지속적 연결 상태가 기본이며 이를 해제하기 위해선 명시적으로 요청 헤더를 수정해야 한다.

## HTTP/1.1 단점

- HTTP HOLB : HTTP/1.1에 들어오면서 파이프라이닝 기술을 통해 한 번에 순차적인 여러 요청을 연속적으로 하고 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄였다. 하지만 만약 처음의 요청에 대한 응답이 오래 걸리는 경우, 그 다음 응답까지의 시간이 지연되는 현상이 발생한다. 이렇게 파이프라이닝 기법은 심각한 문제를 안고 있었으며 이를 Head of Line Blocking 문제라고 하며 줄여서 HOLB 라고도 한다.

- RTT(Round Trip Time) : HTTP의 특성상 Handshake 가 반복적으로 일어나고 또한 불필요한 RTT증가와 네트워크 지연을 초래하여 성능을 저하.

- 무겁고 중복 많은 헤더 구조 : 요청을 할 때 요청헤더에 메타정보를 넣어서 보내게 되는데, 이렇게 요청마다 보내는 정보가 많아져서 헤더가 무거워지고 쿠키 같은 경우는 계속 보내게 되기 때문에 중복도 많아지는 문제 존재.

## HTTP/1.1의 단점들을 보완하고자 나온 HTTP2

HTTP/2가 나오기 전의 개선방법들은..?? CSS/JavaScript/이미지 압축, Image Sprite, 도메인 샤딩(1개의 도메인을 여러개의 서브도메인으로 나눠서 병렬요청하는 기법), 스크립트 파일을 바디태그 끝 직전에 배치

## 보다 개선된 HTTP/2의 특징

HTTP/2는 2012년 구글이 만든 SPDY프로토콜을 기반으로 만들어진 프로토콜

1. Multiplexed Streams : 한 커넥션으로 동시에 여러 개의 메세지를 주고 받을 수 있으며 하나의 스트림은 요청/응답으로 구성되고 여러개의 스트림을 생성할 수 있다. 바로 이것이 스트리밍을 통한 멀티플렉싱이다. 이를 통해 기존의 HTTP/1.1의 문제점인 HLOB를 해결

2. Stream Prioritization : 요청한 리소스간의 우선순위를 설정하기 때문에 스트림 별로 가중치가 매겨지고 브라우저가 리소스들을 수신하는 순서를 적절하게 결정

3. Server Push : 브라우저가 요청하지 않으면 서버는 응답하지 않는 것이 보통이지만, 요청한 HTML 문서에 리소스가 포함되어 있는 경우 서버가 브라우저에게 밀어주는(push) 방식을 취하여 브라우저의 요청을 최소화 (HTTP/1.1에서 클라이언트는 요청한 HTML문서를 수신한 후 HTML문서를 해석하면서 필요한 리소스를 재 요청했다.)

4. Header Compression : 이전 헤더 정보를 유지하고 허프만 인코딩 기법으로 헤더를 압축해서 전송하여 중복과 크기를 줄인다.

## HTTP/3

Google에서 개발한 UDP 기반의 전송 프로토콜 => Google에서 TCP의 구조적 문제로 성능 향상이 어렵다고 판단하여 UDP 기반을 선택

구글에서 QUIC를 도입하여 앞서 문제였던 시간들을 단축시켰다.

- RTT 감소로인한 지연시간 단축 : QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3 Way Handshake 과정을 거치지 않아도 된다. TCP는 RTT가 3번 소요되지만, QUIC는 연결설정에 1 RTT만 소요된다.

- 클라이언트 IP가 바껴도 연결유지 : QUIC은 Connection ID를 사용하여 서버와 연결을 생성한다. Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지

## HTTP 멱등성 ?

우선 멱등성이란 => 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질이다. 이 멱등성이 HTTP와 연관된 이유는 서버의 상태는 멱등성이 유지되어야 하는경우 같은 행위를 여러 번 반복하더라도 같은 효과를 가져야 하기 때문이다.

응답이 다를 수는 있지만, 요청이 의도한 효과를 발휘할 때 멱등성이 유지됨을 의미한다. => 여러 번 요청을 보내더라도 요청에 의한 서버의 상태는 항상 같음.

HTTP 스펙에 명시된 것에 의하면, GET, PUT, DELETE는 멱등성을 가지도록, POST와 PATCH는 멱등성을 가지지 않도록 구현해야 한다

멱등성와 연관지어 PUT & PATCH의 차이를 알아보자.

PUT은 요청 Body로 덮어쓸 데이터가 위치해야 하며, 기존의 리소스가 해당 데이터로 완전히 덮어씌워진다. => 동일한 요청을 여러번 보내더라도 항상 같은 데이터로 덮어씌워지기에 멱등성을 가진다.

PATCH는 HTTP 스펙상 구현 방법에 제한이 없다. 그렇기때문에 요청 Body에 꼭 덮어쓸 데이터가 있을 필요가 없다. 덮어쓸 데이터가 아닌 동작을 지정해줄 수 있는 것이다. => 멱등성을 가지지 않는 것이다.
